
# 1. 프로젝트 소개
- 프로젝트 이름: Quicklendar
- 프로젝트 내용: OCR과 생성형 AI를 활용한 공모전 포스터 인식 및 일정 관리 애플리케이션

### :hourglass: 개발 기간
- 2024.09.01 - 2024.11.30

### :technologist: 인원 구성
- 최유진: Backend & HTTP
- 이태희: Frontend & HTTP
- 이건상: Frontend & OCR / ChatGPT API
<br>

# 2. 주요 기능
- 인사관리: 일반 사용자 및 OAuth 사용자 관리
- 공모전관리: 공모전 정보 관리 및 필터링과 추가 기능
- 보안: BCrypt 활용 암호화 및 JWT 토큰 생성, 만료 시간 관리 및 유효성 검증

<br>

# 3. 개발 환경
| Backend    | Database    | Environment    | Deployment    |
|:----------:|:-----------:|:--------------:|:-------------:|
| Java       | MySQL       | IntelliJ IDEA <br> MySQL Workbench <br> GitHub  | - |
<br>

# 4. 비즈니스 흐름도
![Image](https://github.com/user-attachments/assets/6ec84df3-77e1-46f3-912d-7e65a4969d74)

<br>

# 5. ERD
![Image](https://github.com/user-attachments/assets/4f6e0594-c759-4ae0-83d1-2fa6dcab8efa)

<br>

# 6. 트러블 슈팅

<details>
  <summary>📌 1. 이미지 저장 및 업로드 문제</summary>
  
  - 공모전 정보를 저장할 때, **JSON 데이터와 이미지 파일**을 한 번에 처리하려 했으나, `@ModelAttribute` 애너테이션을 사용할 경우 `MultipartFile`이 `null`로 인식되는 문제가 발생했다.

  - **JSON 데이터와 이미지 파일**을 정상적으로 처리할 수 있도록 API를 개선해야 했다.  
  - 프론트엔드에서 **한 번의 요청으로 이미지와 데이터를 함께 전송**할 수 있도록 구성해야 했다.  

  - `@RequestPart` 애너테이션을 사용하여 **JSON과 이미지 파일**을 별도로 처리하도록 변경했다.  
  - 이미지 원본 이름을 데이터베이스에 저장하고, 상대 경로를 별도로 관리하여 데이터베이스 용량을 절약했다.  

  - `@RequestPart`를 활용하여 JSON 데이터와 `MultipartFile` 이미지를 함께 처리할 수 있게 되었으며, API를 최적화하여 프론트엔드와의 데이터 송수신이 원활해졌다.  

</details>

<details>
  <summary>📌 2. 공모전 필터링 및 정렬 기능 문제</summary>

  - **공모전 목록에서 좋아요 수, 등록일 순 정렬 및 카테고리, 주최자, 공모전 타입별 필터링 기능**을 구현하려 했으나, 백엔드와 프론트엔드 중 어디에서 처리할지 명확한 기준이 없었다.

  - **필터링 및 정렬** 로직을 효과적으로 구현하고, 백엔드의 부하를 줄이는 최적의 방식을 찾아야 했다.

  - 백엔드에서 정렬된 데이터를 제공하고, 프론트엔드에서 필터링을 수행하는 방식으로 결정했다.
  - `findByCategoryAndCompetitionTypeAndHost()` 메서드를 활용하여 필터링된 데이터를 반환하는 API를 구축했다.  

  - 공모전 데이터를 효과적으로 정렬 및 필터링할 수 있는 구조를 완성했으며, 사용자가 원하는 방식으로 데이터를 조회할 수 있도록 개선했다.

</details>

<details>
  <summary>📌 3. OAuth 로그인 문제 (구글 & 네이버)</summary>

  - OAuth2.0 로그인 후, **사용자 정보가 세션에만 저장되고 데이터베이스에 저장되지 않는 문제**가 발생했다. 또한, **구글 OAuth 리다이렉트 URI가 플러터 환경과 맞지 않아 로그인 처리가 불가능**했다.

  - OAuth 로그인 후 사용자 정보를 데이터베이스에 저장하는 방식이 필요했다.
  - 구글 OAuth 리다이렉트 URI를 로컬 환경에 맞게 설정해야 했다.

  - OAuth 인증 후 사용자 정보를 데이터베이스에 저장하는 로직을 추가했다.
  - 구글 OAuth 리다이렉트 URI를 로컬 환경(`10.0.2.2:8080`)에 맞게 설정했다.

  - OAuth 로그인 시 사용자 정보가 정상적으로 저장되었으며, 플러터 환경에서도 OAuth 인증이 정상적으로 동작했다.

</details>

<details>
  <summary>📌 4. CORS 및 CSRF 보안 설정</summary>
  
  - 플러터 환경에서는 기본적으로 `localhost:8080`이 아닌 `10.0.2.2:8080`을 사용해야 하는데, CORS 설정이 없어서 프론트엔드에서 API 요청 시 `403 Forbidden 오류`가 발생했다.
  - 또한, **CSRF 보호가 활성화**되어 있어 API 요청이 차단되었다.

  - **CORS 설정을 추가하여 특정 도메인의 접근을 허용**해야 했다.  
  - `Spring Security`에서 **CSRF 보호를 비활성화**해야 API가 정상적으로 동작할 수 있었다.

  - `WebConfig`에 CORS 설정을 추가하여 특정 도메인의 접근을 허용했다.  
  - `Spring Security` 설정에서 **CSRF 보호를 비활성화**하여 REST API가 정상적으로 동작하도록 수정했다.

  - CORS 및 CSRF 설정을 조정하여 프론트엔드와 백엔드 간 API 요청이 정상적으로 이루어졌으며, Flutter 환경에서도 API 호출이 원활해졌다.

</details>

<br>

# 7. 회고

- `Spring`과 `HTTP`를 처음 학습하고 이 프로젝트를 진행하며 **API 설계, 보안 설정, 데이터 처리 방식** 등 다양한 요소를 경험할 수 있었다.

- 특히, **JWT 인증과 RESTful API 설계, 도메인 분리, 이미지 업로드 처리** 등의 기술적 개선을 거치면서 실제 서비스 환경에서 고려해야 할 사항들을 보다 깊이 이해할 수 있었다.

- 앞으로는 더 **확장 가능한 구조**로 개발할 수 있도록 도메인 설계와 데이터 처리 방식에 대해 계속 고민해야겠다.

- 로컬 환경에서만 동작하는 서비스가 아쉬워서 `AWS Lambda`와 `AWS EC2`와 같은 클라우드 서비스를 이용해보려 했지만, `AWS`에 대한 이해가 부족하여 실행으로 옮기지 못했다.

- 다음 프로젝트에서는 `AWS Lambda`나 `AWS EC2`를 활용한 **배포를 직접 경험**하고 이를 마무리하는 것을 목표로 삼아야겠다.

- 또한, **팀 프로젝트**도 처음으로 경험하며 짧은 **협업 과정**을 거치게 되었다.

- 특히, 프론트엔드와 백엔드 간 API 요청을 위해 의사소통하는 과정에서 **명확한 전달**이 중요하다는 점을 크게 느꼈고, 지금 생각해보면 **빠르고 정확한 피드백**을 위해 오프라인에서 짝 프로그래밍 등의 개발 방법이 유독 좋아보였다.
